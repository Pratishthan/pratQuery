1.	Purpose 
This document talks about the online query engine which can query on the different databases based on view configuration and provide result, or send the view request with a unique token to deferred system which executes and adds back the data. This system is independent of the databases which should be connected, these connection management, querying, sending request to deferred system is left to the providers which can be added in runtime. 

2.	Requirement 
With the introduction of new archival system, there is a need for a central system which can query on the different stages of archival systems namely gold , silver and bronze. Since Bronze data is archival data there is no need for querying support on this directly. Following are the different use cases which are meant to be handled by this system. 
A.	Common system which can be reused in this big data infra and even without it.
B.	Simple/Complex table queries on gold storage. These queries can have named parameters which will be passed as a part of the request. These should be responded immediately. 
C.	An Open API standard JSON needs to be generated which can be used by swagger UI.
D.	Any query which involves silver table needs to be generate a unique ID , send it to spark job for executing and respond this ID to user for enquiring later.
E.	Silver Table queries will be executed using a spark job and result is added back to gold storage. 
F.	Silver Table queries can be of special type where the data can be appended to existing gold tables. 
G.	Submitting the jobs shouldn’t be part of the query engine and should be a runtime plugin logic. It can be by publishing a kafka message or by adding an entry into file which is being streamed.
H.	Deferred requests data should be allowed to queried later and if the results is not yet generated it should respond pending.
I.	Results generated by deferred requests needs to be cleared of after a certain TTL.
J.	Deferred jobs response can be http 201(accepted). With a short code in response. This will help other systems to write common logic which will understand that it needs to pool/query later for the result.  
K.	Spring boot application for easier resource management and shipping. 










3.	Process
A.	Actual Process
 
B.	Big Data View (Just renamed)
 

A.	Query Request can come from either pratishthan UI or some other pratishthan system. On path /view/<ViewName>
B.	This request is accepted by the main query engine and based on view configuration, it decides if its immediate response or deferred response and call appropriate queryProvider.
C.	If the view is deferred a unique token is generated using the view spec query params and time at which the request was sent, then this message along with token is sent to deferred system for processing and also this token is responded to the user for enquiring later.
D.	If view is not deferred the request is sent to appropriate plugin which fetches the connection execute the query and return back array of records, which is inturn responded to caller.
E.	For Deferred requests user can query later with token on path /deferred/<token>. Token is first validated and if its valid it send to the appropriate plugin setup to fetch the data and respond back.



4.	Configuration : There are two parts of configuration required for this applications 
A.	Application.yml: This configuration is read by all plugins and query engine. Following are the properties required. 
-	server.port:  port on which the application will accept requests.
-	pratQuery.deferredDatasource : default connection where deferred requests results are selected. 
-	pratQuery.datasources: Array of JSONObjects which contain information required for the plugin to execute the query or forward the request. Following is the structure of the object
o	Provider name is the key of the object. This object is directly read by the appropriate plugin 
	Name of the connection. A unique name provided for the connection which can be later referred in views.
•	Parameters required for the provider to establish a connection.  
-	Spring.profiles.include: Array of strings which are sub application yml files which can contain some extra parameters which are required for the plugin. Eg: kafka in spring cloud stream. 
-	pratQuery.oasBaseJSON : This is openAPI spec base JSON for entire application. The contain application related data.
B.	Views.json : These are actual views config which are placed in folders as mentioned below. 
-	Product : All the product jsons can be placed here by adding here directly or creating subfolders specific for the entity for easier management. 
-	Implementation : All the implementations jsons which are either new views created at implementation site or modified product views. Even here the views can be placed in this folder or can be further classified and placed in sub folders.
In these folders the leaf node is a JSON which is of the following structure. 
•	Name: Name of the view. This has to be an unique value.
•	Desc: Description of view.
•	deferred_response: For views which will be responded later this flag can be set to true. Boolean.
•	Resp_fileds: Array. This contains the list fields which will be responded back and their data types. 
o	Name: field name/Key which will be responded. 
o	Desc: Description of the field which will be responded. 
o	Type: data type of the field. It can be STRUCT for nested structures. It can be object for nested undefined structured. 
o	Fields: If the type is STRUCT this will be array of nested structure.
•	Query_params : This is an array which contains set of fields which will be passed as a part of request
o	Name: It is the name of query parameter in the query. 
o	Desc: Description of the field which will be responded. 
o	Type: data type of the field. 
•	query: String. This is the actual string where query will be executed.
•	Connection : It’s a name with which the db connection details can be identified. In the application.yml.
•	Table_append: This is a Boolean flag which is applicable in case of silver storage queries where final result is added to a existing table.
•	Append_details: This is a custom JSON which needs to be passed to silver query engine. 
•	Disable: By default will be true. But if set to false the view will not be available for querying.



Examples

A.	Immediate response View 
{
  "name":"Acct_balance",
    "deferred_response":false,
  "resp_fields":[
    {"name":"account_id","desc":"Account ID ","type":"string"},
    {"name":"account_type","desc":"Account Type","type":"string"},
    {"name":"account_balance","desc":"Account Balance","type":"flaot"},
    {"name":"account_opening_date","desc":"Account Opening Date","type":"string"}
  ],
  "query_params":[
    {"name":"customer_id","desc":"Customer ID ","type":"String"},
    {"name":"name","desc":"Name of the account holder","type":"String"},
    {"name":"city","desc":"Name of the account holder","type":"String"}],
   "db_query":"select acct_id, acct_type, acct_bal, acct_open_date from AccountBalance where customer_id= ? AND ( account_name= ? OR account_city= ? )",
   "connection":"Accounts"
}


B.	Deferred response  View
{
  "name":"Acct_balance_silver",
"deferred_response":false,
  "resp_fields":[
    {"name":"account_id","desc":"Account ID ","type":"string"},
    {"name":"account_type","desc":"Account Type","type":"string"},
    {"name":"account_balance","desc":"Account Balance","type":"flaot"},
    {"name":"account_opening_date","desc":"Account Opening Date","type":"string"}
  ],
  "query_params":[
    {"name":"customer_id","desc":"Customer ID ","type":"String"},
    {"name":"name","desc":"Name of the account holder","type":"String"},
    {"name":"city","desc":"Name of the account holder","type":"String"}],
   "db_query":"select acct_id, acct_type, acct_bal, acct_open_date from AccountBalance where customer_id= ? AND ( account_name= ? OR account_city= ? )",
   "connection":"AccountsTran",
   "Table_append":false
}
5.	Startup flow: 
-	Application.yml is read by both engine and individual providers. Providers only select the provider related variables and initialize the connections or setup some data for the provider to execute a process.
-	Product views are read and validated. Later implementation views are read and replaced with product views if there is a view with same name. 
-	OpenAPI spec JSON is generated for these views which will have only one option that is http get. 
-	All these data are generated using a builder class and later added to a bean which can be later accessed from application.context.


